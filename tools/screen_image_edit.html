<!doctype html>

<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Screen Image Edit</title>
  <style>
  	table#editor {
  		border-collapse: collapse;
  		user-select: none;
  		margin-bottom: 20px;
  	}
  	table#palette {
  		border-collapse: none;
  		user-select: none;
  		margin-bottom: 10px;
  	}
  	table#brush {
  		border-collapse: none;
  		user-select: none;
  		margin-bottom: 10px;
  	}
  	td.tile {
  		border: 1px solid #666;
  		width: 4px;
  		height: 4px;
  		color: #808080;
  	}
  	td.paletteCell {
  		border: 1px solid #666;
  		width: 16px;
  		height: 16px;
  	}
  	td.brushCell {
  		border: 1px solid #666;
  		width: 16px;
  		height: 16px;
  		text-align: center;
  	}
  	td.layoutCell {
  		vertical-align: top;
  	}
  	span#textOutput {
  		font-family: "Monaco", fixed;
  		font-size: 9pt;
  	}
  	div.p {
  		margin-top: 20px;
  	}
  	body {
  		font-family: "Helvetica Neue", Helvetica, swiss;
  		font-size: 12pt;
  	}
  
  </style>
</head>

<script>

var tileMap;
var mapWidth, mapHeight;
var paletteTileCount = 4;
var isMouseDown = false;
var selectedColor = 0;
var brushSize = 1;


function initTableCells() {
	// Default size
	resizeMap(160, 72);
	
	// Add mousedown and mouseup handlers
	document.onmousedown = function() {
		isMouseDown = true;
	}
	
	document.onmouseup = function() {
		isMouseDown = false;
	}

	// Add table cells to the empty "palette" table element
	var paletteTable = document.getElementById("palette");
	var paletteRow = paletteTable.insertRow(0);
	for (var x=0; x<paletteTileCount; ++x) {
		var cell = paletteRow.insertCell(x);
		cell.classList.add("paletteCell");
		cell.style.backgroundColor = colorForTile(x);
		cell.onmousedown = (function() {
			var localX = x;
			return function() {
				selectColor(localX); 
			}
		})();
	}
	
	// Add table cells to the empty "brush" table element
	var brushTable = document.getElementById("brush");
	var brushRow = brushTable.insertRow(0);
	for (var x=0; x<5; ++x) {
		var cell = brushRow.insertCell(x);
		cell.classList.add("brushCell");
		cell.innerText = x + 1;
		cell.onmousedown = (function() {
			var localX = x;
			return function() {
				setBrushSize(localX + 1);
			}
		})();
	}
	
	// Initial setup
	updateEditor();
	selectColor(1);
	setBrushSize(1);
}

function resizeMap(width, height) {

	// Update internal variables
	tileMap = Array();
	for (var i=0; i<width*height; ++i) {
		tileMap.push(0);
	}
	mapWidth = width;
	mapHeight = height;

	// Update UI
	var table = document.getElementById("editor");

	// Remove old table cells
	table.innerHTML = "";

	// Add table cells to the empty "editor" table element
	var x, y;
	for (y=0; y<mapHeight; ++y) {
		var row = table.insertRow(y);
		for (x=0; x<mapWidth; ++x) {
			var cell = row.insertCell(x);
			cell.classList.add("tile");
			cell.onmousedown = (function() {
				var localX = x;
				var localY = y
				return function() {
					paintAt(localX, localY); 
				}
			})();
			cell.onmouseenter = (function() {
				var localX = x;
				var localY = y
				return function() {
					if (isMouseDown) {
						paintAt(localX, localY); 
					}
				}
			})();
		}
	}

	updateEditor();
}

function selectColor(x) {
	// Change the selected cell in the palette table.
	var paletteTable = document.getElementById("palette");
	var previousCell = paletteTable.rows[0].cells[selectedColor];
	previousCell.style.outline = "none";
	var newCell = paletteTable.rows[0].cells[x];
	newCell.style.outline = "3px solid #333";

	// Update global var
	selectedColor = x;
}

function setBrushSize(x) {
	// Change the selected cell in the brush table.
	var brushTable = document.getElementById("brush");
	var previousCell = brushTable.rows[0].cells[brushSize - 1];
	previousCell.style.outline = "none";
	var newCell = brushTable.rows[0].cells[x - 1];
	newCell.style.outline = "3px solid #333";

	// Update global var
	brushSize = x;
}

function paintAt(x, y) {
	var startX = x - Math.floor(brushSize / 2);
	var startY = y - Math.floor(brushSize / 2);
	for (var row=0; row<brushSize; ++row) {
		for (var column=0; column<brushSize; ++column) {
			var tileX = startX + column;
			var tileY = startY + row;
			if (tileX >= 0 && tileX < mapWidth && tileY >= 0 && tileY < mapHeight) {
				changeTile(startX + column, startY + row);
			}
		}
	}

	updateEditor();
	updateTextOutput();
}

function changeTile(x, y) {
	tileMap[x + mapWidth * y] = selectedColor;
}

function colorForTile(x) {
	switch (x) {
	case 1: // White
		return "#FFFFFF";
	case 2: // Black
		return "#000000";
	case 3: // Red
		return "#c00000";
	case 0: 
	default: // Clear/empty
		return "#808080";
	}
}


function updateEditor() {
	var x, y;
	var color;
	var table = document.getElementById("editor");
	for (y=0; y<mapHeight; ++y) {
		for (x=0; x<mapWidth; ++x) {
			color = colorForTile(tileMap[x + mapWidth * y]);			
			table.rows[y].cells[x].style.backgroundColor = color;
		}
	}
}

function updateFromTextInput() {
	var textInput = document.getElementById("textInput");
	console.log("Textarea value length = " + textInput.value.length);

	// Remove any whitespace within the string
	var b64string = textInput.value.replace(/\s/g, "");
	var packedData = atob(b64string);
	var row = 0;
	var column = 0;

	console.log("packedData length = " + packedData.length);

	for (var i in packedData) {
		var c = packedData.charCodeAt(i);
		for (var x=0; x<4; ++x) {
			var tile = (c >> (6 - x * 2)) & 0x03;
			tileMap[row * mapWidth + column] = tile;
			++column;
			if (column >= mapWidth) {
				++row;
				column = 0;
			}
		}
	}
	
	updateEditor();
	updateTextOutput();
}

function updateTextOutput() {
	var packedData = String();
	var c;

	for (var row = 0; row < mapHeight; ++row) {
		c = 0;
		for (var column = 0; column < mapWidth; ++column) {
			var tile = tileMap[row * mapWidth + column];
			c = c << 2 | tile & 0x03;

			if (column % 4 == 3) {
				packedData += String.fromCharCode(c);
				c = 0;
			}
		}
	}

	// Convert to base64.
	var b64string = btoa(packedData);

	// Split up string in order to break up the long base64 string into lines of 80 chars.
	var i = 0;
	var lines = Array();
	while (i < b64string.length) {
		lines.push(b64string.substr(i, 80));
		i += 80;
	}
	var outputString = "";
	for (i in lines) {
		var line = lines[i];
		outputString += line + "<br>";
	}
	
	var textOutput = document.getElementById("textOutput");
	textOutput.innerHTML = outputString;
}

function hexString(x) {
	var s = x.toString(16).toUpperCase();
	if (s.length % 2) {
		s = "0" + s;
	}
	return s;
}

function clearMap() {
	fillMapWithValue(0);
}

function fillMap() {
	fillMapWithValue(selectedColor);
}

function fillMapWithValue(value) {
	for (var x=0; x<tileMap.length; ++x) {
		tileMap[x] = value;
	}
	updateEditor();
	updateTextOutput();
}

</script>

<body onload="initTableCells()">

<div>
	<table id="layout">
		<tr>
			<td class="layoutCell" colspan=4><table id="editor"></table></td>
		</tr>
		<tr>
			<td class="layoutCell"><table id="palette"></table></td>
			<td class="layoutCell"><table id="brush"></table></td>
			<td class="layoutCell">
				<button type="button" onclick="clearMap();">Clear</button>
				<button type="button" onclick="fillMap();">Fill</button>
			</td>
			<td class="layoutCell">
				Resize:
				<button type="button" onclick="resizeMap(160, 72);">160x72</button>
			</td>
		</tr>
	</table>
</div>

<div class="p"><b>In:</b>
	<form>
		<textarea cols=132 rows=24 id="textInput"></textarea>
		<button type="button" onclick="updateFromTextInput();">Update</button>
	</form>
</div>

<div class="p"><b>Out:</b><br>
	<span id="textOutput"></span>
</div>


</table>  	
</body>
</html>
